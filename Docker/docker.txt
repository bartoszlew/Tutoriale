Docker tutorial
============================
for begginers:
https://docs.docker.com/get-started
https://www.youtube.com/watch?time_continue=35&v=M7ZBF-JJWVU

obraz (image) -  The file system and configuration of our application which are used to create containers.
kontener (containers) -  Running instances of Docker images — containers run the actual applications. A container includes an application and all of its dependencies. 
warstwy (layers) - A Docker image is built up from a series of layers. Each layer represents an instruction in the image’s Dockerfile. Each layer except the last one is read-only.
Dockerfile - A text file that contains all the commands, in order, needed to build a given image. The Dockerfile reference page lists the various commands and format details for Dockerfiles.
Volumes - A special Docker container layer that allows data to persist and be shared separately from the container itself. 
		  Think of volumes as a way to abstract and manager your persistent data separately from the application itself.


skróty klawiszowe
---------------------
Ctrl+P i Ctrl+Q - wylazi z kontenera nie wylaczajac go ??



info o serwerze dockera
-----------------------
docker -v


uruchamianie i dzialanie na kontenerach
---------------------------------------
docker container run -it -p 3000:80 --name jakas_nazwa_kontenera <obraz>	- odpala/tworzy kontener z obrazu i nadaje mu nazwe
	-p 
	--nazwa - nadaje nazwekontenerowi (bez tego docker nada losowa nazwe)
docker container run -it <obraz> <komenda> - tworzy kontener z obrazu, odpala komende o podlacza sie do interfejsu tty
	-i tryb interaktywny - Keep STDIN open even if not attached
	-t dołączenie terminalu do jego danych wyjściowych i wejściowych (Allocate a pseudo-TTY)
docker container attach <nazwa/id-konterenara> - "podłaczenie sie" do działającego kontenera
docker container ls	- listuje działające kontenery
docker container ls -a - listuje wszystkie kontenery (działające, zpauzowane, niedzialajace, itd.) 
docker container rm  <nazwa/id-kontenera> - usuwa kontener
dokcer container start <nazwa/id-kontenera> - startuje kontener 
dokcer container stop <nazwa/id-kontenera> - grzecznie zatrzymuje kontener (wysyla pierw SIGTERM a po chwili SIGKILL do procesu głównego wewnątrz kontenera)
docker container kill <nazwa/id-kontenera> - zatrzymuje kontener (wysyla SIGKILL do kontenera, a dokładniej do procesu głównego wewnątrz kontenera)
		--signal okresla jaki konkretnie sygnal wyslac do procesu glownego kontenera (domyslnie SIGKILL)
docker container pause <nazwa/id-kontenera> - //doczytac
docker container unpouse <nazwa/id-kontenera> - //doczytac
docker container exec <nazwa/id-kontenera> - we can send a command in to the container to run by using the exec command
docker exec -it <id_kontenera> <jakas-komenda> - podlacza sie do uruchomionego kontenera i odpala basha
docker container top - wyswietla uruchomione procesy na kontenrze, cos jak komenda "ps" (UID, PID, STIME, TTY, CMD)
docker container stats - wyswieta statyskyki kontenera live, cos jak komenda "top" (CPU, MEM, NET I/O, BLOCK I/O, PIDS)
docker container diff <id kontenera> Pokazuje różnice w plikach lub folderach między kontenerem a obrazem.
docker container commit - zostanie utworzony nowy obraz zawierający wszystkie dokonane zmiany i gotowy do późniejszego uruchomienia
docker container create - Tworzy nowy kontener na podstawie obrazu.

interakcja z kontenerami
--------------------------
kopiowanie jednego pliku na kontener:
docker cp mycontainer:/foo.txt foo.txt

kopiowanie wielu plikow na kontener:
docker cp src/. mycontainer:/target
docker cp mycontainer:/src/. target


działanie na obrazach 
-----------------------------
docker imaes - listuje lokalną lista obrazow
	-q pokazuje tylko id obrazu
docker image pull <nazwa_obrazu> - sciaga obraz z dockera hub albo innego rejestru obrazów
docker image ls - lista obrazow w systemie
docker image inspect <nazwa/id obrazu> - info o obrazie // dane sa w formacie json
docker image inspect --format "{{ json .RootFS.Layers }}"  <nazwa/id obrazu> - to co wyzej ale z filtrowanym info
docker image rm <nazwa/id-obrazu> - usuwa obraz dockera
docker image tag 
docker image history <id kontenera> - pokazuje historię w jaki sposób budowany był konkretny obraz



budowanie obrazów
-----------------------------
Budowanie z kontenera na podstawie innego obrazu:
1.Odpalamy jakis kontener z gotowego obrazu, podlaczamy sie do konsoli i cos zmieniamy, np. instalujemy jakis nowy soft
	docker container run -ti ubuntu bash
	apt-get update
	apt-get install -y figlet
2.Sprawdzamy roznice miedzy roznice jakie wprowadzilismy
	docker container diff <id kontenera>
3.Tworzymy nowy obraz z kontenera ktory utworzylismy
	docker container commit <id kontenera>
4.dobrze jest otagowac nowy obraz
	docker image tag <IMAGE_ID> jakis_tag
    docker image ls

Budowanie obrazu uzywajac pliku Dockerfile
1. Tworzymy plik Dockerfile >>
	FROM alpine 						// okresla bazowy obraz ktory ma byc uzyty do budowy
	RUN apk update && apk add nodejs	// uruchamia polecenia (w tym przypadku pak update i apk add)
	COPY . /app							// kopiuje pliki z katalogu roboczego do kontenera
	WORKDIR /app						// definiujemy katalog roboczy dla kontenera po starcie
	CMD ["node","index.js"]				// podajemy komende jaka ma byc uruchomiona po starcie kontenera

2. budujemy obraz w katalogu z plikiem Docker
	docker build -t jakas_nazwa:versja . 
			np. docker image build -t hello:v0.1 .

Instrukcje pliku Dockerfile:
FROM <obraz> albo <obraz>:<znacznik> albo <obraz>@<skrócony_opis>
MAINTAINER nazwa_twórcy
ADD <ścieżka lub adres URL miejsca źródłowego> <ścieżka miejsca docelowego> - kopiuje pliki z miejsca źródłowego na hoście do własnego systemu plików obrazu Dockera
	<katalog docelowy> identyfikuje ścieżkę bezwzględną lub ścieżkę względną w odniesieniu do katalogu określonego przez instrukcję WORKDIR
	- jesli kopiujemy archiwum, to ADD automatem je rozpakuje
	- mozna pobrac pliki z sieci
COPY <ścieżka miejsca źródłowego> <ścieżka miejsca docelowego> - skopiuje nowe pliki lub katalogi ze ścieżki i doda je do systemu plików kontenera reprezentowanego przez ścieżkę
	- preferowana nad ADD (jeśli nie trzeba korzystać z dodatkowych funkcji ktore posiada ADD)
CMD 




konfigurowanie sieci w dockerze
----------------------------------
http://training.play-with-docker.com/docker-networking-hol/

docker network ls	- command to view existing container networks on the current Docker host
docker network inspect <nazwa/id sieci> - info o konfiguracji sieci
docker info | grep Network - list network driver plugins	

Bridge Networking:
Every clean installation of Docker comes with a pre-built network called bridge.
docker run -p 8080:80 nginx - odpala kontener i mapuje port 80(docker) na 8080(serwer)
		-p 8080:80  i natuje port 8080 serwera dockera na 80 kontenera (The port mapping is actually port address translation (PAT)).
Po odpaleniu kontenera domyslnie podlacza sie on do interfejsu bridge, brctl show - pojawi sie w kolumnie interfaces pod docker0


Udostępnianie i mapowanie portów
---------------------------------
EXPOSE - Sygnalizuje, że na określonym porcie dostępna jest usługa. Instrukcja używana jest w pliku Dockerfile,
		 który zapewnia, że udostępnione porty są otwarte dla innych kontenerów.
--expose - Są to równorzędne polecenia, choć opcja --expose pozwala również podać zakres portów jakoargument (na przykład --expose=1000-2000 )
-p - Opcja określa regułę mapowania portów, mapując port kontenera na port komputera hosta. W ten sposób port jest dostępny poza obrębem Dockera. 
	 Jeśli nie określono żadnego portu hosta, Docker automatycznie go przydzieli.
		np. docker run -p<port_hosta>:<port_kontenera> <identyfikator lub nazwa obrazu>
-P - Opcja mapuje dynamicznie (losowo	) przydzielony port komputera hosta na wszystkie porty udostępnione za pomocą instrukcji EXPOSE lub opcji -expose.
--expose roznica -p - W przprzypadku udostępniania portu za pomocą instrukcji EXPOSE usługa w kontenerze jest niedostęp-
	na poza obrębem Dockera, lecz jest dostępna z poziomu innych kontenerów Dockera. Opcja -p zawiera w sobie --expose.


Wolumeny dockera
-----------------
docker run -it -v /Users/jarek/testDir/:/data ubuntu
docker run -it -v /data2 ubuntu
docker run --name docker-nginx -p 80:80 -d --volumes-from myWebsiteData nginx
docker volume create
VOLUME w Dockerfile
info o volumenie:
	docker run -it -v /data2 ubuntu
docker run -it -v /data2 ubuntuw - podłaczenie volumenu o nazwie data do katalogu w kontenerze /data
docker rm -v <nazwa_kontenera> - usuwa wolumen bez pytania, nawet jesli jakies kontenery uzywaja tego wolumenu
docker volume rm - usuwa wolumen ale tylko wtedy kiedy żaden kontener go nie uzuwa
docker volume rm $(docker volume ls -qf dangling=true) - usuwa wszystkie wolumeny, do których nie odwołuje się żaden kontener
--driver; -d - sterownik wolumenu,  (domyslnie "local")

Docker security
------------------------
http://training.play-with-docker.com/security-seccomp/
http://training.play-with-docker.com/security-capabilities/
https://www.projectatomic.io/blog/2015/08/why-we-dont-let-non-root-users-run-docker-in-centos-fedora-or-rhel/

jak wpakowac sie na hosta z poziomu dockera: docker run -ti --privileged -v /:/host fedora chroot /host 
bindujemy / hosta na /host i chrootujemy z poziomu dockera na /host z uprawnieniami roota :)

Docker logowanie
------------------------
docker login --username <dockerId> --password <hasło>



Docker Swarm Mode
--------------------
http://training.play-with-docker.com/ops-stage2/
http://training.play-with-docker.com/ops-s1-swarm-intro/
http://training.play-with-docker.com/orchestration-hol/

Swarm: Stos, Serwisy, Zadania
stos (stack) - group of interrelated services and dependencies. Orchestrated as a unit. Production applications are one stack, and sometimes more.
				w skrocie grupa serwisów powiazanych ze soba, skladających się na całość stosu.
serwis (service) - a stack component, including a container image, numbers of repolicas (tasks), ports, and update policy
				jeden lub wiecej takich samych kontenerów tworzących jedna aplikację?
zadanie (task) - unit of services and scheduling in Docker. One container instance per task


docker swarm init --advertise-addr $(hostname -i) - Initializing Docker Swarm Manager
docker swarm join --token <hash z outputu docker dwarm init> <ip:port z outputu docker swarm init> - dodanie workera do docker swarm
docker swarm ls - wyswietla wszystkie nody w swarmie (managery i workery)

Tworzenie "stosu" serwisow - czyli wdrazanie/tworzenie/konfigurowanie/uruchamianie grup serwisow w swarmie:
docker-stack.yml - plik yaml z konfiguracja swarma. Definiuje nasz cały stos (stack): architekturę usług, liczbę instancji, sposób połączenia wszystkiego, 
					obsługę aktualizacji dla każdej usługi. Jest to kod źródłowy do naszego projektu aplikacji. 
					Przykładowy plik zawiera m.in. wpisy
						services - zawiera poszczególne składniki dla aplikacji, wewnatrz 
									*image: obraz dockera użyty do budowania serwisu 
									*ports: port na ktorym ma dzialac serwis
									*networks: wiadomix
									*deploy: konfiguracja rozmieszczania, liczby kontenerow itp.
										replicas: 
										...
												

docker stack deploy --compose-file=docker-stack.yml jakis_stos
docker stack ls	- wyswietla  "zdelpoyowane" stosy i liczbe serwisów (aplikacji) nalezących do stosu
docker stack services <jakis_stos> - wyswietla info o serwisach(aplikacjach) w stocku (Id obrazu, nazwa, porty, liczba replik)
docker service ps <jakis_serwis_ze_stosu> - listuje zadania (repliki?) danego serwisu, np. na jakim nodzie dziala
docker service scale <jakis_serwis_ze_stosu> =5 - dorzucenie taskow do serwisu (skalowanie, zmiana liczby konenerów(taskow) w serwisie dla np. zwiekszenia wydajnosci)




Kubernetes // wydzielic do osobnego pliku
---------------------
https://kubernetes.io/docs/tutorials/kubernetes-basics/
http://cockpit-project.org/
cockpit-kubernetes.x86_64 : Cockpit user interface for Kubernetes cluster
