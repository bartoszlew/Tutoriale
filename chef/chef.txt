przygotowanie srodowiska
---------------------------
ChefDK - narzedzia i soft chefa (knife, chef-client, Berkshelf, itp.)

tworzenie cookbookow od podstaw
---------------------------------
chef generate cookbook jakas_nazwa - tworzynowy drzewo folderów cookbooka z podstawowa zawartoscia
tworzenie plikow:
	chef generate -h
	np.
	chef generate template [sciezka do cookbooka] nazwa.pliku
  	np. chef generate cookbooks cookbooks/learn_chef_httpd index.html
	chef generate attribute ./ default

sciagniecie gotowego przepisu ze chef.supermarket:
knife cookbook site download [nazwa-cookbooka]

najprosciej jest kopiowac gotowe cookbooki i je modyfikowac



podstawy - attributes, recipe, template, files
-------------------------------------------------

attributes (atrybuty) - wartosci atrybutow. czyli ustawienie zmiennych = klucz-wartosc
	default['sms']['port'] = 8456
		default - moze byc: default, normal, override -> priorytety atrybutu: https://docs.chef.io/roles.html
		['sms'] - jakas grupa, nazwa moze byc jakakolwiek, najczesciej ustawiaomy nazwe cookbooka zeby bylo wiadomo o co chodzi, to jest tylko "grupa" zmiennych
		['port'] - nazwa zmiennej

recipe (przepisy)- w recipe jest glowna konfiguracja, odwolujemy sie tam do plikow, atrybutow, templatow
	odwolanie:
	:config_var => node['configs']['config_var']
		- config nazwa atrybutu
		node[] wartosc atrybutu

template - uzycie atrybutu. tak jak pliki ale nie sa statyczne. mozemy odwolac sie/wstawic zmienne ktore sa zdefiniowane w attributes
	@nazwa_zmiennej
	atrybut mozemy bezposrednio  wstawic do recipe bez odwolywania sie do zmiennej:
	zamiast :config_var => node['configs']['config_var'] , wstawiamy default['sms']['port']

files - statyczne pliki które beda wrzucane na endpointa



attributes
------------------------
zmiana atrybutow w:

-cookbookach - dla cookbooka
	-attributes
	-recipes
	.. ?
-rolach - dla grupy ktora ma przypiata role
-nodach - dla pojedynczego noda

osobno dla jednego noda - wrzucamy w bezposrednio w node w sekcji atrybutow
"zasobyp: {
	"action": "upgrade"
	}


cookbooks
-------------------------
iteracja:
--
node['nginx_selinux']['ports'].each do |seport|
    execute 'selinux add port' do
        command "/sbin/semanage port -a -t http_port_t -p tcp #{seport}"
        not_if "/usr/sbin/semanage port -l | grep -E '^http_port_t.*tcp.*[^0-9]#{seport}($|[^0-9].*$)'>/dev/null"
    end
end


if--else:
--
if node[:fqdn] != 'host.domena.pl'
        selinux_policy_boolean 'nis_enabled' do
                value false
        end
end



wrapper cookbooks
-----------------------
https://blog.chef.io/2017/02/14/writing-wrapper-cookbooks/
https://realityforge.org/code/2012/11/19/role-cookbooks-and-wrapper-cookbooks.html

For every cookbook and/or recipe we wanted to customize we created a separate 'wrapper' recipe
that set the required attributes and then included the recipe from the original cookbook.
This resulted in a layout that looked like the following;


dodanie noda do chefa (bootstrap)
-------------------------------------
https://learn.chef.io/modules/manage-a-node-chef-server/rhel/bring-your-own-system/bootstrap-your-node#/

- sprawdzic polaczenie ssh do noda (najlepiej ustawic logowanie po kluczu)

knife bootstrap ADDRESS --ssh-user USER --sudo --ssh-identity-file IDENTITY_FILE --node-name node1-centos --run-list 'recipe[learn_chef_httpd]'
	--node-name - ustawia nazwe noda w  Chef serwerze, nie musi to byc nazwa hostnama
	np. knife bootstrap 34.238.115.178 --ssh-user centos --sudo --identity-file ~/.ssh/private_key --node-name node1-centos --run-list 'recipe[learn_chef_httpd]'


sprawdzenie:
	knife node list
	knife node show node1-centos

update cookbooka:
	np. knife ssh 'name:node1-centos' 'sudo chef-client' --ssh-user USER --identity-file IDENTITY_FILE --attribute ipaddress



pobieranie cookbookow z chef supermarket
-------------------------------------------
knife supermarket - pobiera ale bez zaleznosci
Berkshelf - tool that helps you resolve cookbook dependencies. Can retrieve the cookbooks that
		your cookbook depends on and can upload your cookbooks to your Chef server.

Berksfile
berks install - sciaga z supermarketu zaleznosci cookbokow zdefiniowanych w Berksfile
berks show [cookbook] pokazuje sciezke na dysku do sciagnietego przez berks cookbooka
berks upload - wrzuca cookbooka i zaleznosci do chef servera




Chef-client
-----------------
chef-client -o "recipe[jakis_cookbook@0.1.2]"  - odpalanie innej wersji cookbooka na nodzie
knife ssh 'name:node1-centos' 'sudo chef-client' --ssh-user centos --ssh-identity-file ~/.ssh/private_key



============================ Test Kitchen i testowanie cookbookow ============================
https://learn.chef.io/modules/local-development/windows/virtualbox/apply-a-cookbook#/
https://docs.chef.io/config_yml_kitchen.html

Test Kitchen
---------------
Test Kitchen - w skrocie tworzy chwilowe srodowisko testowe towrzac wirtualke za pomoca vagranta i hyperwizora, np. virtualboxa
	i na niej odpala testy cookbooka. dodatkowo przeprowadza testy kodu.... //do uzupenienia
	Test Kitchen umożliwia określenie szczegółów dotyczących maszyny wirtualnej, w tym jej systemu operacyjnego, dostępnej pamięci, nazwy hosta,
	i ustawień sieciowych, oraz jak uruchomić Chefa - w tym, które przepisy i które testy należy uruchomić.
  Test Kitchen builds the Vagrantfile for you and is the interface you use to create, destroy, and run Chef on your instances.

Bento - repo z gotowymi do uzycia boxami Vagranta (predefiniowane dla chefa?)
.kitchen.yml - definiuje, co jest potrzebne do uruchomienia Test Kitchen, w tym, z którego dostawcy wirtualizacji korzystać,
		jak uruchomić Chef i na jakich platformach uruchomić swój kod.

kitchen list - pokazuje co jest w "kuchni"




https://docs.chef.io/chef_solo.html


rpm -qa --queryformat  "%{VERSION}" jakas_paczka' -> wyciagnieczie zmiennej paczki
chef-client -z -r "cookbook::test1" -l info testowanie cookbooka lokalnie  (test1 - nazwa przepisu z /recipe)
	do przepisu trzeba wpakowac Chef::Log::info("#{jakas zmienna}") zeby wywalilo wartosc zmiennej




============================ Knife ==============================
https://docs.chef.io/knife_search.html

knife status - sprawdza kiedy ostatnio odpalil sie chef-client na nodach
knife node show [node] - SPRAWDZENIE co ma przypisany host
knife node show [node] -Fj -  SPRAWDZENIE co ma przypisany host
knife cookbook list - listuje aktualne cookbooki na serverze chefa z numerem wersji
knife search node "roles:$ROLE_NAME" -i - listuje wszystkie nody ktore maja przypisana konkretna role
knife search node "chef_environment:nazwa_env" -i - listuje wszystkie nody ktore maja przypisany nazwa_env

knife cookbook upload [jakis_cookbook] - upload cookbooka do servera chefa (jesli nie jest automatycznie wysylany)
knife upload environments/jakies_srodowisko.json - ulpad srodowiska

Sprawdzenie czy node i client jest w cefie
	knife node status <nazwa hosta>
	knife client show <nazwa hosta>
Wywalenie noda z chefa:
	knife node delete <nazwa hosta>
	knife client delete <nazwa hosta>

sprawdzanie atrybutow na serverze chefa (czy aktualne)
-------------------------------------------
knife environment show [nazwa_env]

update atrybutow( env/recipe/itp. ) w chefie
no. env jesli na serewrze jest inna wersja niz w gicie
	knife environment from file environments/jakies_srodowisko.json



=====================Chef Vault i Data bag=====================


Data bag
------------------------
plain text:
knife data bag -z create [nazwa_cookbooka] [nazwa_data-buga] - tworzenie data baga
  -z -> plik tworzony lokalnie (nie na serwerze)

encrypted:
//potrzebny jest odpowiedni wpis (sciezka do klucza wspoldzielonego) w .chef/knife.rb
//klucz jest kopiowany z serwera chefa do lokalnego katalogu .chef ?
knife[:secret] = #{current_dir}/plik_klucza
knife data bag -z create --encrypt [nazwa_cookbooka] [nazwa_data-baga] - tworzenie zaszyfrowanego data baga
knife data bag -z show [nazwa_cookbooka] [nazwa_data-buga]  - podglad zaszyfrowanego data baga
knife data bag -z edit - edycja data baga



Tworzenie nowegp vaulta w chefie i wrzucanie do gita
------------------------------------------------------
https://blog.chef.io/2016/01/21/chef-vault-what-is-it-and-what-can-it-do-for-you/

1.tworzymy nowy item w vaulcie w chefie
knife vault list - listuje pudelka z kluczami
knife vault create nazwa-vaulta nazwa_itemu {"klucz":"wartosc"}
	np. knife vault create nh-vault rsoperations {"dbpass":"haslo_plain_tekstem"} // chef zaszyfruje haslo
knife vault show nazwa_vaulta nazwa_itemu - wyswietla co jest w vaulcie // (rozszyfrowane dlatego haslo jest w plain tekscie)

2. tworzymy data baga na gicie (zaszyfrowany vault)
skryptem chef/chef-repo/scripts/vault-dump.sh albo recznie:
- stworzyc katalog w chef/chef-repo/vaults/waw/nazwa_vaulta/
- cd chef/chef-repo/vaults/waw/nazwa_vaulta/
- zaimportowac itema/vaulta z chefa
	knife data bag show nazwa_vaulta nazwa_itemy -Fj  > nazwa_itemu.json --> importuje vaulta z chefa do jsona i zrzuca do pliku
		np. knife data bag show nh-vault rsoperations -Fj > vaults/waw/nh-vault/rsoperations.json
- zaimportowac klucze userów?? dla vaulta
	to samo co wyzej tylko z przyrostkiem "_keys"
		np.knife data bag show radius-server rsoperations_keys -Fj > rsoperations_keys.json -> importuje klucze userow ???
- wyswietlenie zawartosci data baga
	knife data bag show nh-vault nazwa_itemu - to co w knife valut show, tylko w postaci zaszyfrowanej
- wrzucic wygenerowane jsony do gita!

3. przypisanie vaulta do userow/roli/noda
- sprawdzanie jaka role maa przypisany cert:
	knife vault show ssl_certs costam -p all -Fj
- aktualizuje/dodaje certa do roli:
	knife vault update ssl_certs costam -S "role:jakas_rola"
- to samo, tylko ze do kilku roli:
	knife vault update ssl_certs costam -S "role:jakas_rola or role:jakas_rola"


Cookbook (data bag + vault)
----------------------------
	metadata.rb:
		depends ‘chef-vault’
	recipe.rb:
		require 'chef-vault'
		jakas_zmienna = ChefVault::Item.load("nazwa_vaulta", "nazwa_klucza")
		variables :jakas_nazwa_zmiennej=> jakas_zmienna["nazwa_klucza"]  // przypisujemy jakas_nazwa_zmiennej wartosc klucza
	zmienna mozemy wywolac gdzies cookbooku przez: <%= "#{@nazwa_klucza}" %>

	np.
		secret = ChefVault::Item.load("costa", "costam")
		HMAC_SIGN_KEY=<%= "#{@HMAC_SIGN_KEY}" %>

	template '/etc/sssd/sssd.conf' do
	  source 'sssd.conf.erb'
	  owner 'root'
	  group 'root'
	  mode '0600'
	  variables :authtoken => item["sssd_authtoken"]
	  sensitive true  //dodawac do recipe, wtedy chef-client nie bedzie wyswietlal hasla w logach!


===============================================================



===============
	require 'mixlib/shellout'
	local_ver = Mixlib::ShellOut.new('rpm -qa --queryformat  "%{VERSION}" storage-agent')
	local_ver.run_command
	Chef::Log.info(" #{local_ver.stdout} ")

service "jakis_cookbook" do
	action [:stop]
	only_if { node['jakis_cookbook']['version'] != "#{local_ver.stdout}"}
	only_if { node.environment() == 'nh-messor-staging' }
end

yum_package 'jakis_cookbook' do
	action [:remove]
	only_if { node['jakis_cookbook']['version'] != "#{local_ver.stdout}"}
	only_if { node.environment() == 'nazwa_env' }11
end
=================
